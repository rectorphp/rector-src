<?php

declare(strict_types=1);

namespace Rector\PhpSpecToPHPUnit\Naming;

use PhpParser\Node;
use PhpParser\Node\Identifier;
use PhpParser\Node\Name;
use PhpParser\Node\Name\FullyQualified;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Namespace_;
use Rector\Core\Exception\ShouldNotHappenException;
use Rector\Core\PhpParser\Node\BetterNodeFinder;
use Rector\Core\Util\StaticRectorStrings;
use Rector\NodeNameResolver\NodeNameResolver;
use Rector\NodeTypeResolver\Node\AttributeKey;
use Symplify\PackageBuilder\Strings\StringFormatConverter;

final class PhpSpecRenaming
{
    /**
     * @var string
     */
    private const SPEC = 'Spec';

    public function __construct(
        private NodeNameResolver $nodeNameResolver,
        private StringFormatConverter $stringFormatConverter,
        private BetterNodeFinder $betterNodeFinder
    ) {
    }

    public function renameMethod(ClassMethod $classMethod): void
    {
        if ($classMethod->isPrivate()) {
            return;
        }

        $classMethodName = $this->nodeNameResolver->getName($classMethod);
        $classMethodName = $this->removeNamePrefixes($classMethodName);

        // from PhpSpec to PHPUnit method naming convention
        $classMethodName = $this->stringFormatConverter->underscoreAndHyphenToCamelCase($classMethodName);

        // add "test", so PHPUnit runs the method
        if (! \str_starts_with($classMethodName, 'test')) {
            $classMethodName = 'test' . ucfirst($classMethodName);
        }

        $classMethod->name = new Identifier($classMethodName);
    }

    public function renameExtends(Class_ $class): void
    {
        $class->extends = new FullyQualified('PHPUnit\Framework\TestCase');
    }

    public function renameNamespace(Class_ $class): void
    {
        $namespace = $this->betterNodeFinder->findParentType($class, Namespace_::class);
        if (! $namespace instanceof Namespace_) {
            return;
        }

        $namespaceName = $this->nodeNameResolver->getName($namespace);
        if ($namespaceName === null) {
            return;
        }

        $newNamespaceName = StaticRectorStrings::removePrefixes($namespaceName, ['spec\\']);

        $namespace->name = new Name('Tests\\' . $newNamespaceName);
    }

    public function renameClass(Class_ $class): void
    {
        $classShortName = $this->nodeNameResolver->getShortName($class);

        // anonymous class?
        if ($classShortName === '') {
            throw new ShouldNotHappenException();
        }

        // 2. change class name
        $newClassName = StaticRectorStrings::removeSuffixes($classShortName, [self::SPEC]);
        $newTestClassName = $newClassName . 'Test';

        $class->name = new Identifier($newTestClassName);
    }

    public function resolveObjectPropertyName(Class_ $class): string
    {
        // anonymous class?
        if ($class->name === null) {
            throw new ShouldNotHappenException();
        }

        $shortClassName = $this->nodeNameResolver->getShortName($class);
        $bareClassName = StaticRectorStrings::removeSuffixes($shortClassName, [self::SPEC, 'Test']);

        return lcfirst($bareClassName);
    }

    public function resolveTestedClass(Node $node): string
    {
        /** @var string $className */
        $className = $node->getAttribute(AttributeKey::CLASS_NAME);

        $newClassName = StaticRectorStrings::removePrefixes($className, ['spec\\']);
        return StaticRectorStrings::removeSuffixes($newClassName, [self::SPEC]);
    }

    private function removeNamePrefixes(string $name): string
    {
        $originalName = $name;

        $name = StaticRectorStrings::removePrefixes(
            $name,
            ['it_should_have_', 'it_should_be', 'it_should_', 'it_is_', 'it_', 'is_']
        );

        return $name ?: $originalName;
    }
}
